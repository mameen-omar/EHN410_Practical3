// EHN 410 - Mohamed Ameen Omar - u16055323 - 2019

/**
 * @file serverMain.c
 * @authors Mohamed Ameen Omar (u16055323)
 * @authors Douglas Healy (u16018100)
 * @authors Llewellyn Moyse (u15100708)
 * @brief  Main file. 
 * @version 0.1
 * @date 2019-03-19
 * 
 * @copyright Copyright (c) 2019
 * 
 */

// Vulgrind: 
//  valgrind -v --leak-check=yes ./main

// https://gmplib.org
/*
How to use GMP: 
    https://www.cs.colorado.edu/~srirams/courses/csci2824-spr14/gmpTutorial.html
    http://www-oldurls.inf.ethz.ch/personal/fukudak/lect/mssemi/reports/01_rep_DiyoraSalimova.pdf
    https://gmplib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic
    https://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions

*/


#include <gmp.h>
#include <stdarg.h> 
#include <obstack.h> 
#include "stdio.h"
#include "stdlib.h"


int main(int argc, char * argv[])
{   

    // mpz_t is a type for gmp integers. These integers grow dynamically. 
    // Need to explicitly clear or free the memory allocated for a mpz_t using - clear(var)
    mpz_t integ;

    mpz_t* temp = malloc(sizeof(mpz_t));
    mpz_init(temp[0]); 
    mpz_clear(temp[0]); 
    free(temp); 


    // initialize the variable
    mpz_init(integ);
    mpz_set_ui(integ,0);
    
    // gmp_printf("Hello %Zd\n", integ); // use this to print it
    // char* temp = "ABCDEF";

    unsigned int count = 100;
    printf("%d\n", count); 
    mpz_t vec[count]; 

    for(int x = 0; x<count;x++) {
        mpz_init(vec[x]);
    }
    
    
    mpz_set_str(vec[0],"AB", 16); 
    mpz_set_str(vec[1],"CD", 16); //convert string from hex to decimal !! mpz_set_str(where to store, the string, )

    gmp_printf("Hello %Z02X\n", vec[0]); // print in hex

    for(int x = 0; x<count;x++) {
        mpz_clear(vec[x]);
    }
    mpz_clear(integ);

    // unsigned char* mytemp = calloc(5,sizeof(char));
    // for(int x = 0; x < 5; x++){
    //     printf("%p\n", mytemp+x);
    // }
	return 0;
}


/*

#include "rc4.h"

// https://datatracker.ietf.org/doc/rfc6229/
// https://www.rfc-editor.org/rfc/pdfrfc/rfc6229.txt.pdf
// https://tools.ietf.org/id/draft-josefsson-rc4-test-vectors-00.html
// https://tools.ietf.org/id/draft-josefsson-rc4-test-vectors-01.html
// https://tools.ietf.org/html/draft-josefsson-rc4-test-vectors-02
// http://www.potaroo.net/ietf/idref/draft-josefsson-rc4-test-vectors/
// http://www.potaroo.net/ietf/idref/draft-luis140219-curdle-rc4-die-die-die/
// https://www.rfc-editor.org/pipermail/rfc-dist/2011-May/002994.html
// https://crypto.stackexchange.com/questions/20897/what-are-the-plaintexts-for-the-rc4-stream-cipher-test-vectors-in-rfc6229 -- explains the test vectors
// https://www.oryx-embedded.com/doc/rc4_8c_source.html

// constructs the state and initializes the struct
// returns a pointer to the rc4CTX
// caller must free the memory
rc4ctx_t * constructRc4Context() 
{
    rc4ctx_t* rc4Ctx = malloc(sizeof(rc4ctx_t));

    for(size_t x = 0; x < RC4_STATE_SIZE; x++) {
        mpz_init(rc4Ctx->state[x]); 
    }
    rc4Ctx->index1 = 0; 
    rc4Ctx->index2 = 0; 

    return rc4Ctx; 
}


// resets all values
// clears all mpz_t elements
// clears all memory
// sets pointer to null
void destroyRc4Context(rc4ctx_t * rc4Ctx)
{
    for(int x = 0; x<RC4_STATE_SIZE; x++) {
        mpz_clear((*rc4Ctx).state[x]);
    }

    free(rc4Ctx); 
    rc4Ctx = NULL;
}



// inititalize the state of RC4 with the key given
// if the key is hexString convert to ascii string
void rc4Init(rc4ctx_t* rc4Ctx, unsigned char* key, int keylen, int isKeyHex)
{
    for(rc4Ctx->index1 = 0; rc4Ctx->index1 < RC4_STATE_SIZE; rc4Ctx->index1++) {
        mpz_set_ui(rc4Ctx->state[rc4Ctx->index1], rc4Ctx->index1);
    }

    // for(rc4Ctx->index1 = 0; rc4Ctx->index1 < 255; rc4Ctx->index1++) {
    //     gmp_printf("Hello %Z02d\n", rc4Ctx->state[rc4Ctx->index1]);
    // } 
    rc4Ctx->index2 = 0;

    for(rc4Ctx->index1 = 0; rc4Ctx->index1 < RC4_STATE_SIZE; rc4Ctx->index1++) {
        rc4Ctx->index2 = (rc4Ctx->index2 + rc4Ctx->state[rc4Ctx->index1] + key[rc4Ctx->index1 % keylen]) % 256;
        swapStateElements(&rc4Ctx->state[rc4Ctx->index1], &rc4Ctx->state[rc4Ctx->index2]);
    }
    
    
}

// return a single byte of the key stream generated by rc4 
unsigned char* rc4GetByte(rc4ctx_t* rc4Ctx) 
{
    unsigned char* temp = (unsigned char*) "Hello";
    return temp; 
}

void swapStateElements(mpz_t* val1, mpz_t* val2)
{
    int temp = mpz_get_ui(*val1); 
    mpz_set(*val1,*val2);
    mpz_set_ui(*val2,temp);
}





*/